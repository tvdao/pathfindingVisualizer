{"version":3,"sources":["components/Node.jsx","components/Grid.jsx","gridOperations.js","components/algorithms/dijkstra.js","components/algorithms/aStar.js","components/Header.jsx","App.jsx","components/algorithms/bfs.js","components/algorithms/dfs.js","index.js"],"names":["Node","props","col","row","isWall","isStart","isFinish","isVisitedAfter","startToEnd","mouseDownEvent","mouseUpEvent","mouseEnterEvent","nodeStyle","className","join","data-col","data-row","data-finish","data-start","onMouseDown","onMouseUp","onMouseEnter","Grid","grid","placeWalls","map","rowId","node","nodeId","isVisited","initialGrid","push","prevNode","distance","Infinity","sortNodesByDistance","unvisitedNodes","sort","node1","node2","getAllNodes","nodes","length","updateUnvisitedNeighbors","unvisitedNeighbors","getUnvisitedNeighbors","i","neighbors","filter","neighbor","distanceToFinishNode","Header","visualize","clearGrid","clearWall","onClick","App","useState","startNodeRow","startNodeCol","finishNodeRow","finishNodeCol","isRunning","mousePressed","currRow","currCol","gridState","setGridState","animate","visitedNodesInOrder","nodesShortestPath","setTimeout","animateShortestPath","currNode","newGrid","newNode","nodesInShortestPath","finishNode","shortestPath","unshift","isGridClear","slice","algo","startNode","queue","nodesVisited","currentNode","shift","nextNode","bfs","stack","pop","dfs","closestNode","dijkstra","Math","abs","calcDistanceToFinNode","aStar","event","currentTarget","dataset","finish","start","Number","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.10cb524d.chunk.js","sourcesContent":["/**\n * Filename: Node.jsx\n * Author: Tri Dao\n * Date: 4/28/21\n * \n * Summary of File:\n *      This file is the Node component. It deals with how\n * a node is interacted with and the styles applied depending\n * on the node is interacted.\n */\n\nimport React from \"react\";\nimport \"./Node.css\";\n\n/**\n * Creates the node component and set its properties based on\n * the props passed down. Styles are also depedent on the props\n * passed down\n * \n * @param props - The properties passed down to the compoenent \n * \n * @returns A node component\n */\nconst Node = (props) => {\n\n    const {col, row, isWall, isStart, isFinish, isVisitedAfter} = props;\n\n    const {startToEnd, mouseDownEvent, mouseUpEvent, mouseEnterEvent} = props;\n\n    // Applys css classNames depending on props passed in\n    let nodeStyle = [\n        \"node\",\n        isStart ? \"start\" : \"\",\n        isFinish ? \"finish\" : \"\",\n        isVisitedAfter ? \"visited\" : \"\",\n        startToEnd ? \"shortestPath\" : \"\",\n        isWall ? \"wall\" : \"\"\n    ]\n\n    return (\n        <div className = {nodeStyle.join(\" \")}\n             data-col = {col}\n             data-row = {row}\n             data-finish = {isFinish}\n             data-start = {isStart}\n             onMouseDown = {mouseDownEvent}\n             onMouseUp = {mouseUpEvent}\n             onMouseEnter = {mouseEnterEvent}\n        >\n        </div>\n    )\n}\n\nexport default Node;","/**\n * Filename: Grid.jsx\n * Author: Tri Dao\n * Date: 4/28/21\n * \n * Summary of File: \n *      This file is a Grid component. It maps out the 2d grid, and creates\n * a Node for each [row][col]. It places the all the nodes within a div\n */\n\nimport React from \"react\";\nimport Node from \"./Node.jsx\";\nimport \"./Grid.css\"\n\n/**\n * Creates the grid component, that will be used to display the grid on the website. \n * Uses Node components to represent the individual cells of the grid\n * \n * @param grid - 2d array, representing the grid\n * @param placeWalls - placeWalls method that will be passed down to node component\n * @param mouseDownEvent - mouseDownEvent method that will be passed down to node component\n * @param mouseUpEvent - mouseUpEvent method that will be passed down to node component\n * @param mouseEnterEvent - mouseEnterEvent method that will be passed down to node component\n * \n * @return Node component for each [row][col of the grid, all encased in a div\n */\nconst Grid = ({grid, placeWalls, mouseDownEvent, mouseUpEvent, mouseEnterEvent}) => {\n    return (\n        <div className=\"grid\">\n            {grid.map((row, rowId) => {\n                return (\n                    <div key={rowId}>\n                        {row.map((node, nodeId) => {\n                            return (\n                                <Node \n                                    key = {nodeId}\n                                    col = {node.col}\n                                    row = {node.row}\n                                    isWall = {node.isWall}\n                                    isStart = {node.isStart}\n                                    isFinish = {node.isFinish}\n                                    isVisited = {node.isVisited}\n                                    isVisitedAfter = {node.isVisitedAfter}\n                                    startToEnd = {node.startToEnd}\n                                    placeWalls = {placeWalls}\n                                    mouseDownEvent = {mouseDownEvent}\n                                    mouseUpEvent = {mouseUpEvent}\n                                    mouseEnterEvent = {mouseEnterEvent}\n                                />\n                            )\n                        })}\n                    </div>\n                )\n            })}\n        </div>\n    )\n}\n\nexport default Grid;","/**\n * Filename: gridOperations.js\n * Author: Tri Dao\n * Date: 4/28/21\n * \n * Summary of FIle:\n *      This file contains the method that creates the initial\n * default Grid when the App loads and renders for the first time.\n */\n\n/**\n * Creates an initial 2d array of a \"node\" object with many default properties\n * used for the graph traversal algorithms\n * \n * @returns 2d array of the \"node\" object\n */\nconst initialGrid = () => {\n    let grid = [];\n    for (let row = 0; row < 20; row++) {\n        grid.push([]);\n        for (let col = 0; col < 40; col++) {\n            grid[row].push({\n                row: row,\n                col: col,\n                isWall: false,\n                prevNode: null,\n                isStart: (row === 10 && col === 10) ? true : false,\n                isFinish: (row === 10 && col === 30) ? true : false,\n                isVisited: false,\n                isVisitedAfter: false,\n                startToEnd: false,\n                distance: Infinity,\n            })\n        }\n    }\n    return grid;\n}\n\nexport {initialGrid}","/**\n * Filename: dijkstra.js\n * Author: Tri Dao\n * Date: 4/28/21\n * \n * Summary of File: \n *      This file contains the dijkstra algorithm and how it traverses the grid\n */\n\n/**\n * Dijkstra algoritm that will be ran on the grid\n * \n * @param grid - The grid that the djikstra algorithm will be ran on\n * @param startNode - The startNode of the grid\n * @param finishNode - The finishNode of the grid\n * \n * @return - An array that contains the nodes visited by dijkstra\n */\nconst dijkstra = (grid, startNode, finishNode) => {\n    let nodesVisited = [];\n    startNode.distance = 0;\n    // store all unvisited nodes in array\n    const unvisitedNodes = getAllNodes(grid);\n\n    // Loop until unvisitedNodes is empty\n    while (unvisitedNodes.length !== 0) {\n        sortNodesByDistance(unvisitedNodes);\n        const closestNode = unvisitedNodes.shift();\n\n        // Is currentNode is not a wall\n        if (!closestNode.isWall) {\n            if (closestNode.distance === Infinity) {\n                return nodesVisited;\n            }\n            closestNode.isVisited = true;\n            nodesVisited.push(closestNode);\n            if (closestNode === finishNode) {\n                return nodesVisited;\n            }\n            updateUnvisitedNeighbors(closestNode, grid);\n        }\n    }\n}\n\n/**\n * Sorts the nodes by their distance from the start Node\n * \n * @param unvisitedNodes - Array of unvisited nodes\n */\nconst sortNodesByDistance = (unvisitedNodes) => {\n    unvisitedNodes.sort((node1, node2) => node1.distance - node2.distance);\n}\n\n/**\n * Gets all the nodes in the grid and store in array\n * \n * @param grid - Current grid\n * \n * @returns array of all the nodes in the grid\n */\nconst getAllNodes = (grid) => {\n    let nodes = [];\n    for (let row = 0; row < grid.length; row++) {\n        for (let col = 0; col < grid[0].length; col++) {\n            nodes.push(grid[row][col]);\n        }\n    }\n    return nodes;\n}\n\n/**\n * Add 1 to the current distance of the univisted nodes\n * \n * @param node - The node that will add 1 to the distance of it's neighbor nodes\n * @param grid - The grid contains the nodes that wil be updated\n */\nconst updateUnvisitedNeighbors = (node, grid) => {\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n    for (let i = 0; i < unvisitedNeighbors.length; i++) {\n        unvisitedNeighbors[i].distance = node.distance + 1;\n        unvisitedNeighbors[i].prevNode = node;\n    } \n}\n\n/**\n * Gets the unvisited neighbors of the node that the algorithm is on\n * \n * @param node - The node that will have its neighbors pushed into an array\n * @param grid - The current grid that the node is in\n * \n * @returns Array that only has nodes that are not visited\n */\nconst getUnvisitedNeighbors = (node, grid) => {\n    let neighbors = [];\n    const {col, row} = node;\n    if (row > 0) {\n        neighbors.push(grid[row-1][col]);\n    }\n    if (row < grid.length  - 1) {\n        neighbors.push(grid[row+1][col]);\n    }\n    if (col > 0) {\n        neighbors.push(grid[row][col-1]);\n    }\n    if (col < grid[0].length - 1) {\n        neighbors.push(grid[row][col+1]);\n    }\n    return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n\nexport {dijkstra};","/**\n * Filename: aStar.js\n * Author: Tri Dao\n * Date: 4/28/21\n * \n * Summary of File:\n *      This file contains the A* algorithm. \n */\n\n/**\n * aStar algorithm that will be ran on the grid\n * \n * @param grid - The grid that the aStar algorithm will be ran on\n * @param startNode - The startNode of the grid\n * @param finishNode - The finishNode of the grid\n * \n * @return - An array that contains the nodes visited by aStar\n */\nconst aStar = (grid, startNode, finishNode) => {\n    let nodesVisited = [];\n    startNode.distance = 0;\n    // store all unvisited nodes in array\n    const unvisitedNodes = getAllNodes(grid);\n\n    // Loop until unvisitedNodes is empty\n    while (unvisitedNodes.length !== 0) {\n        sortNodesByDistance(unvisitedNodes);\n        const closestNode = unvisitedNodes.shift();\n\n        // Is currentNode is not a wall\n        if (!closestNode.isWall) {\n            if (closestNode.distance === Infinity) {\n                return nodesVisited;\n            }\n            closestNode.isVisited = true;\n            nodesVisited.push(closestNode);\n            if (closestNode === finishNode) {\n                return nodesVisited;\n            }\n            updateUnvisitedNeighbors(closestNode, grid);\n        }\n    }\n}\n\n/**\n * Sorts the nodes by their distance from the start Node\n * \n * @param unvisitedNodes - Array of unvisited nodes\n */\n const sortNodesByDistance = (unvisitedNodes) => {\n    unvisitedNodes.sort((node1, node2) => node1.distance - node2.distance);\n}\n\n/**\n * Gets all the nodes in the grid and store in array\n * \n * @param grid - Current grid\n * \n * @returns array of all the nodes in the grid\n */\n const getAllNodes = (grid) => {\n    let nodes = [];\n    for (let row = 0; row < grid.length; row++) {\n        for (let col = 0; col < grid[0].length; col++) {\n            nodes.push(grid[row][col]);\n        }\n    }\n    return nodes;\n}\n\n/**\n * Add 1 to the current distance of the univisted nodes\n * \n * @param node - The node that will add 1 to the distance of it's neighbor nodes \n *               and their distance to the finish Node\n * @param grid - The grid contains the nodes that wil be updated\n */\n const updateUnvisitedNeighbors = (node, grid) => {\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n    for (let i = 0; i < unvisitedNeighbors.length; i++) {\n        unvisitedNeighbors[i].distance = node.distance + 1 + unvisitedNeighbors[i].distanceToFinishNode;\n        unvisitedNeighbors[i].prevNode = node;\n    } \n}\n\n/**\n * Gets the unvisited neighbors of the node that the algorithm is on\n * \n * @param node - The node that will have its neighbors pushed into an array\n * @param grid - The current grid that the node is in\n * \n * @returns Array that only has nodes that are not visited\n */\n const getUnvisitedNeighbors = (node, grid) => {\n    let neighbors = [];\n    const {col, row} = node;\n    if (row > 0) {\n        neighbors.push(grid[row-1][col]);\n    }\n    if (row < grid.length  - 1) {\n        neighbors.push(grid[row+1][col]);\n    }\n    if (col > 0) {\n        neighbors.push(grid[row][col-1]);\n    }\n    if (col < grid[0].length - 1) {\n        neighbors.push(grid[row][col+1]);\n    }\n    return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n\nexport {aStar}","/**\n * Filename: Header.jsx\n * Author: Tri Dao\n * Date: 4/28/21\n * \n * Summary of File:\n *      This file is the Header componenet. It displays the header of the file\n * which contains the different options of interacting with the grid.\n */\n\nimport React from \"react\";\nimport \"./Header.css\";\n\n/**\n * Creates the header of the website. Allows the user to interact\n * with the grid by deciding the algorithm that will be displayedd\n * \n * @param visualize - Visualize method passed down in order to be \n *                    called when a div is clicked on\n * @param clearGrid - ClearGrid method passed down to be called when \n *                    clearGrid div is clicked on\n * @param clearWall - ClearWall method passed down to be called when \n *                    clearWall div is clicked on\n * \n * @returns The header componenet\n */\nconst Header = ({visualize, clearGrid, clearWall}) => {\n    return (\n        <div className=\"head\">\n        <header>\n            <div className=\"wrapper\">\n            <div className=\"logo\">\n                <h1>Pathfinding Visualizer</h1>\n            </div>\n            <nav>\n                <div className=\"nav-button\" onClick={() => visualize(\"bfs\")}>BFS</div>\n                <div className=\"nav-button\" onClick={() => visualize(\"dfs\")}>DFS</div>\n                <div className=\"nav-button\" onClick={() => visualize(\"dijkstra\")}>Dijkstra</div>\n                <div className=\"nav-button\" onClick={() => visualize(\"A*\")}>A*</div>\n                <div className=\"nav-button\" onClick={() => clearWall()}>Clear Walls</div>\n                <div className=\"nav-button\" onClick={() => clearGrid()}>Clear Grid</div>\n            </nav>\n            </div>\n        </header>\n        </div>\n    )\n}\n\nexport default Header;","/**\n * Filename: App.jsx\n * Author: Tri Dao\n * Date: 4/28/21\n * \n * Summary of File:\n *      This file is the App component. It keeps track of the grid state and \n * updates based on what is happening. For instance, mouse events are kept \n * track of and the grid state is updated based on what is clicked/dragged. \n * It also contains the visualization method, displaying how the algorithm\n * traverses on the grid.\n */\n\nimport React, {useState} from \"react\";\nimport Grid from \"./components/Grid.jsx\"\nimport {initialGrid} from \"./gridOperations\";\nimport {bfs} from \"./components/algorithms/bfs.js\";\nimport {dfs} from \"./components/algorithms/dfs.js\";\nimport {dijkstra} from \"./components/algorithms/dijkstra.js\";\nimport {aStar} from \"./components/algorithms/aStar.js\";\nimport Header from \"./components/Header.jsx\";\n\n/**\n * Displays the grid and header. Handles the dynamic changes of the\n * board. Handles the visualization aspect of the project.\n * \n * @return Board component that contains the header of the website and\n * the grid where the algorithms take place.\n */\nconst App = () => {\n\n    // Keeps track of the grid state (ex. the changes of each node in the grid)\n    const [gridState, setGridState] = useState({\n        grid: initialGrid(),\n        startNodeRow: 10,\n        startNodeCol: 10,\n        finishNodeRow: 10,\n        finishNodeCol: 30,\n        isRunning : false,\n        mousePressed: false,\n        currRow: null,\n        currCol: null,\n        isFinish: false,\n        isStart: false\n    });\n\n    const calcDistanceToFinNode = () => {\n        const {finishNodeRow, finishNodeCol, grid} = gridState;\n        for (let row = 0; row < grid.length; row++) {\n            for (let col = 0; col < grid[0].length; col++) {\n                gridState.grid[row][col].distanceToFinishNode = Math.abs(row - finishNodeRow) + Math.abs(col - finishNodeCol);\n            }\n        }\n    }\n\n    /**\n     * Calls the algorithm that is requested, then calls method that \n     * graphically displays how the algorithm searches for the finish \n     * (red) node on the grid.\n     * \n     * @param algo - The algorithm that will be visualized\n     */\n    const visualize = (algo) => {\n        const {grid, startNodeRow, startNodeCol, finishNodeRow, finishNodeCol} = gridState;\n        const startNode = grid[startNodeRow][startNodeCol];\n        const finishNode = grid[finishNodeRow][finishNodeCol];\n        let visitedNodesInOrder;\n        let shortestPath;\n        // Won't visualize if grid is not clear. \n        if (isGridClear()) {\n            if (algo === \"bfs\") {\n                visitedNodesInOrder = bfs(grid, startNode, finishNode);\n            }\n            if (algo === \"dfs\") {\n                visitedNodesInOrder = dfs(grid, startNode, finishNode);\n            }\n            if (algo === \"dijkstra\") {\n                visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n            }\n            if (algo === \"A*\") {\n                calcDistanceToFinNode();\n                visitedNodesInOrder = aStar(grid, startNode, finishNode);\n            }\n            // shortest path from start to finish\n            shortestPath = nodesInShortestPath(finishNode);\n            animate(visitedNodesInOrder, shortestPath);\n        }\n    };\n\n    /**\n     * Animates how the algorithm searches on the grid. After, animates the \n     * shortest path from start node to finish node.\n     * \n     * @param visitedNodesInOrder - Array that contains the order that the nodes were \n     *                              traversed in based on algorithm\n     * @param nodesShortestPath - Array of nodes that correspond to the shortest\n     *                            path the algorithm found from start to finish node\n     */\n    const animate = (visitedNodesInOrder, nodesShortestPath) => {\n        for (let i = 0; i <= visitedNodesInOrder.length; i++) { \n            // Once it goes past the finish node, animate the shortest path\n            if (i === visitedNodesInOrder.length) {\n                setTimeout( () => {\n                    animateShortestPath(nodesShortestPath);\n                }, 10 * i);\n                // After animate is finished, the algorithm is no longer running \n                setGridState({\n                    ...gridState,\n                    isRunning: false\n                })\n                return;\n            }\n            // Animates the visited nodes\n            setTimeout( () => {\n                const currNode = visitedNodesInOrder[i];\n                const {row, col} =currNode;\n                const newGrid = gridState.grid;\n                // isVisitedAfter if true will apply different css to the node\n                const newNode = {\n                    ...currNode,\n                    isVisitedAfter: currNode.isStart || currNode.isFinish ? false : true\n                }\n                newGrid[row][col] = newNode;\n                setGridState({\n                    ...gridState,\n                    grid: newGrid,\n                    isRunning: true\n                })\n            }, 10 * i)\n        }  \n    }\n\n    /**\n     * Handles animating the shortest path\n     * \n     * @param nodesShortestPath - Shortest path from start node to finish node \n     *                            based on algorithm\n     */\n    const animateShortestPath = (nodesShortestPath) => {\n        for (let i = 0; i < nodesShortestPath.length; i++) {\n            setTimeout( () => {\n                const currNode = nodesShortestPath[i];\n                const {row, col} =currNode;\n                const newGrid = gridState.grid;\n                // startToEnd handles css for the shortest path, different from isVisitedAfter\n                const newNode = {\n                    ...currNode,\n                    startToEnd: currNode.isStart || currNode.isFinish ? false : true\n                }\n                newGrid[row][col] = newNode;\n                setGridState({\n                    ...gridState,\n                    grid: newGrid\n                })\n            }, 50 * i)\n        }\n    }\n\n    /**\n     * Gets the shortest path by traversing the previous node, starting at the finish\n     * node.\n     * \n     * @param finishNode - the finishNode of the current grid\n     *  \n     * @returns An array of the shortest path from start node to finish node \n     */\n    const nodesInShortestPath = (finishNode) => {\n        let shortestPath = [];\n\n        let currNode = finishNode;\n\n        // Stops at startNode, since startNode prevNode = null\n        while (currNode !== null) {\n            // unshift adds node to beginning of array\n            shortestPath.unshift(currNode);\n            currNode = currNode.prevNode;\n        }\n        return shortestPath;\n    }\n\n    /**\n     * Takes in the row and col from the mouse events, and changes the\n     * property of the node clicked to change it to a wall\n     * \n     * @param col - The column where the wall is placed\n     * @param row - The row where the wall is placed\n     * \n     * @returns The updated grid with the node that became a wall\n     */\n    const placeWalls = (col, row) => {\n        let newGrid = gridState.grid;\n        if (!gridState.grid[row][col].isStart && !gridState.grid[row][col].isFinish) {\n            newGrid[row][col].isWall = true;\n        }\n        return newGrid;\n    }  \n\n    /**\n     * Handles when the mouse clicks down on a node. Different cases if\n     * the node is the startNode, finishNode, or empty node. Changes gridState\n     * based on what is clicked down\n     * \n     * @param event - The node that is clicked down on\n     */\n    const mouseDownEvent = (event) => {\n        let {col, row, finish, start} = event.currentTarget.dataset;\n        col = Number(col);\n        row = Number(row);\n        // If algorithm is running on grid, click down events won't have any effect\n        if (!gridState.isRunning) {\n            // If click down on start node\n            if (start === \"true\") {\n                setGridState({\n                    ...gridState,\n                    isStart: true,\n                    mousePressed: true,\n                    currCol: col,\n                    currRow: row\n                })\n            }\n            // If click down on finish node\n            else if (finish === \"true\") {\n                setGridState({\n                    ...gridState,\n                    isFinish: true,\n                    mousePressed: true,\n                    currCol: col,\n                    currRow: row\n                })\n            }\n            // If click down on emptyNode, places wall on node\n            else {\n                let newGrid = placeWalls(col, row);\n                setGridState({\n                    ...gridState,\n                    grid: newGrid,\n                    mousePressed: true,\n                    currCol: col,\n                    currRow: row\n                })\n            }\n        }\n    }\n\n    /**\n     * Handles the event where the mouse hovers over a node. Can \"drag\"\n     * start node to any position, same with finish node. Can place walls\n     * by dragging.\n     * \n     * @param event - The node that is hovered over by the mouse\n     */\n    const mouseEnterEvent = (event) => {\n        let {col, row} = event.currentTarget.dataset;\n        col = Number(col);\n        row = Number(row);\n        // Only run if algorithm is not running\n        if (!gridState.isRunning) {\n            // Only run if mouse is pressed down\n            if (gridState.mousePressed) {\n                // If current node is the start node\n                if (gridState.isStart) {\n                    // Can only drag start node to position if it is not a wall node or finish node\n                    if (!gridState.grid[row][col].isWall && !gridState.grid[row][col].isFinish) {\n                        let newGrid = gridState.grid;\n                        // Changes the previous start node isStart to false\n                        newGrid[gridState.currRow][gridState.currCol].isStart = false;\n                        // Changes current start node isStart to true\n                        newGrid[row][col].isStart = true;\n                        setGridState({\n                            ...gridState,\n                            grid: newGrid,\n                            startNodeCol: col,\n                            startNodeRow: row,\n                            currCol: col,\n                            currRow: row\n                        })\n                    }\n                }\n                // if current node is the finish node\n                else if (gridState.isFinish) {\n                    // Can only drag finish node to position if it is not a wall node or finish node\n                    if (!gridState.grid[row][col].isWall && !gridState.grid[row][col].isStart) {\n                        let newGrid = gridState.grid;\n                        // Changes previous finish node isFinish to false\n                        newGrid[gridState.currRow][gridState.currCol].isFinish = false;\n                        // Changes current finish node isFinish to true\n                        newGrid[row][col].isFinish = true;\n                        setGridState({\n                            ...gridState,\n                            grid: newGrid,\n                            finishNodeCol: col,\n                            finishNodeRow: row,\n                            currCol: col,\n                            currRow: row\n                        })\n                    }\n                }\n                // if current node is an empty node\n                else {\n                    // Place wall if empty node\n                    let newGrid = placeWalls(col, row);\n                    setGridState({\n                        ...gridState,\n                        grid: newGrid\n                    })\n                }\n            }\n        }\n    }\n\n    /**\n     * Handles when mouse is released. \n     * \n     * @param event - The node that the mouse is released on \n     */\n    const mouseUpEvent = (event) => {\n        let {col, row} = event.currentTarget.dataset;\n        col = Number(col);\n        row = Number(row);\n        // Nothing happens if algorithm is running\n        if (!gridState.isRunning) {\n            // If mouse was clicked down on start Node\n            if (gridState.isStart) {\n                setGridState({\n                    ...gridState,\n                    startNodeCol: col,\n                    startNodeRow: row,\n                    isStart: false,\n                    mousePressed: false\n                })\n            }\n            // If mouse was clicked down on finish Node\n            else if (gridState.isFinish) {\n                setGridState({\n                    ...gridState,\n                    finishNodeCol: col,\n                    finishNodeRow: row,\n                    isFinish: false,\n                    mousePressed: false\n                })\n            }\n            // If mmouse was clicked down on emptyy Node\n            else {\n                setGridState({\n                    ...gridState,\n                    mousePressed:false\n                })\n            }\n        }\n    }\n\n    /**\n     * Clears the grid after algorithm is ran. Changes the properties\n     * of the every node to the default node properties.\n     */\n    const clearGrid = () => {\n        let grid = gridState.grid;\n        for (let row = 0; row < grid.length; row++) {\n            for (let col = 0; col < grid[0].length; col++) {\n                grid[row][col].isVisitedAfter = false;\n                grid[row][col].startToEnd = false;\n                grid[row][col].isVisited = false;\n                grid[row][col].prevNode = null;\n                grid[row][col].distance = Infinity;\n            }\n        }\n        setGridState({\n            ...gridState,\n            grid: grid\n        })\n    }\n\n    /**\n     * Clears the walls on the grid. Sets each node isWall property to false\n     */\n    const clearWall = () => {\n        let grid = gridState.grid;\n        if (!gridState.isRunning) {\n            for (let row = 0; row < grid.length; row++) {\n                for (let col = 0; col < grid[0].length; col++) {\n                    grid[row][col].isWall = false;\n                }\n            }\n            setGridState({\n                ...gridState,\n                grid: grid\n            })\n        }\n    }\n\n    /**\n     * Checks if the grid is cleared, i.e. each node on grid has default\n     * properties prior to calling the visualize function\n     * \n     * @returns True if clear, false otherwise  \n     */\n    const isGridClear = () => {\n        let grid = gridState.grid.slice();\n        for (let row = 0; row < grid.length; row++) {\n            for (let col = 0; col < grid[0].length; col++) {\n                if (grid[row][col].isVisitedAfter || grid[row][col].startToEnd) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    return (\n        <div>\n            <Header \n                visualize = {visualize}\n                clearGrid = {clearGrid}\n                clearWall = {clearWall}\n            />\n            <Grid\n                grid = {gridState.grid}\n                placeWalls = {placeWalls}\n                mouseDownEvent = {mouseDownEvent}\n                mouseUpEvent = {mouseUpEvent}\n                mouseEnterEvent = {mouseEnterEvent}\n            />\n        </div>\n    )\n}\n\nexport default App;","/**\n * Filename: bfs.js\n * Author: Tri Dao\n * Date: 4/28/21\n * \n * Summary of File:\n *      This file contains the bfs algorithm. It deals with\n * how bfs is called on the grid.\n */\n\n/**\n * The function deals with how bfs is ran on the grid. Searching\n * for the finish Node starting from the start Node.\n * \n * @param grid - The grid that bfs will be called on\n * @param startNode - The node that bfs will start at\n * @param finishNode - The node that bfs is searching for and end at\n * \n * @returns An array of the nodes visited from bfs algorithm\n */\nconst bfs = (grid, startNode, finishNode) => {\n\n    let queue = [startNode];\n\n    let nodesVisited = [];\n\n    while (queue.length !== 0) {\n        // Gets element that was first put in the array \n        let currentNode = queue.shift();\n\n        // Return when currentNode is at finishNode\n        if (currentNode === finishNode) {\n            nodesVisited.push(currentNode);\n            return nodesVisited;\n        }\n\n        // Don't push node if its a wall or if its been visited\n        if (!currentNode.isWall && !currentNode.isVisited) {\n            currentNode.isVisited = true;\n            nodesVisited.push(currentNode);\n            const {col, row} = currentNode;\n            let nextNode;\n            // Ensures that algo won't go past the top row of the grid\n            if (row > 0) {\n                nextNode = grid[row-1][col];\n                if (!nextNode.isVisited) {\n                    queue.push(nextNode);\n                    nextNode.prevNode = currentNode;\n                }\n            }\n            // Ensures that algo won't go past bottom row of the grid\n            if (row < grid.length-1) {\n                nextNode = grid[row+1][col];\n                if (!nextNode.isVisited) {\n                    queue.push(nextNode);\n                    nextNode.prevNode = currentNode\n                }\n            }\n            // Ensures that algo won't go past furthest left column of the grid\n            if (col > 0) {\n                nextNode = grid[row][col-1];\n                if (!nextNode.isVisited) {\n                    queue.push(nextNode);\n                    nextNode.prevNode = currentNode\n                }\n            }\n            // Ensures that algo won't go past furthest right column of the grid\n            if (col < grid[0].length-1) {\n                nextNode = grid[row][col+1];\n                if (!nextNode.isVisited) {\n                    queue.push(nextNode);\n                    nextNode.prevNode = currentNode\n                }\n            }\n        }\n    }\n}\n\nexport {bfs};","/**\n * Filename: dfs.js\n * Author: Tri Dao\n * Date: 4/28/21\n * \n * Summary of File: \n *      This file contains the dfs algorithm. Deals with how\n * the algorithm is called on the grid\n */\n\n/**\n * The function deals with how dfs is ran on the grid. Searching\n * for the finish Node starting from the start Node.\n * \n * @param grid - The grid that dfs will be called on\n * @param startNode - The node that dfs will start at\n * @param finishNode - The node that dfs is searching for and end at\n * \n * @returns An array of the nodes visited from dfs algorithm\n */\nconst dfs = (grid, startNode, finishNode) => {\n\n    let stack = [startNode];\n\n    let nodesVisited = [];\n\n    while (stack.length !== 0) {\n        // Gets the element that was last in the array\n        let currentNode = stack.pop();\n\n        // Return when currentNode is at finishNode\n        if (currentNode === finishNode) {\n            nodesVisited.push(currentNode);\n            return nodesVisited;\n        }\n\n        // Don't push node if its a wall or if its been visited\n        if (!currentNode.isWall && !currentNode.isVisited) {\n            currentNode.isVisited = true;\n            nodesVisited.push(currentNode);\n            const {col, row} = currentNode;\n            let nextNode;\n            // Ensures that algo won't go past the top row of the grid\n            if (row > 0) {\n                nextNode = grid[row-1][col];\n                if (!nextNode.isVisited) {\n                    stack.push(nextNode);\n                    nextNode.prevNode = currentNode;\n                }\n            }\n            // Ensures that algo won't go past bottom row of the grid\n            if (row < grid.length-1) {\n                nextNode = grid[row+1][col];\n                if (!nextNode.isVisited) {\n                    stack.push(nextNode);\n                    nextNode.prevNode = currentNode\n                }\n            }\n            // Ensures that algo won't go past furthest left column of the grid\n            if (col > 0) {\n                nextNode = grid[row][col-1];\n                if (!nextNode.isVisited) {\n                    stack.push(nextNode);\n                    nextNode.prevNode = currentNode\n                }\n            }\n            // Ensures that algo won't go past furthest right column of the grid\n            if (col < grid[0].length-1) {\n                nextNode = grid[row][col+1];\n                if (!nextNode.isVisited) {\n                    stack.push(nextNode);\n                    nextNode.prevNode = currentNode\n                }\n            }\n        }\n    }\n}\n\nexport {dfs};","/**\n * Filename: index.js\n * Author: Tri Dao\n * Date: 4/28/21\n * \n * Summary of File:\n *    This file renders the entire website.\n */\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from \"./App\"\n\nReactDOM.render(\n  <App />,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}